scheme  GroupingBasics =
class
  type 
    Person = Text,
    Relation = (Person >< Person)-set,
    Group = Person-set,
    Grouping = Group-set
    
  value /* auxilliary functions */
    r : Relation = { ("Anna", "Henrik"), ("Anna", "Frederik"), ("Henrik", "Frederik"), 
        ("Anna", "Mette"),
        ("Hans", "Mette"), ("Hans", "Joachim"), ("Mette", "Joachim")
    },
    badRelation : Relation = {("friend", ""), ("", "friend"), ("","")},
    
    grp1 : Group = {"Hans","Henrik"},
    grp2 : Group = {"Mette", "Frederik"},
    grp3 : Group = {"Joachim", "Peter", "Anna"},
    ging : Grouping = {grp1, grp2, grp3},
    

    isFriendsRelation : Relation -> Bool
    isFriendsRelation(r) is (all p : Person >< Person :- p isin r => validPair(p)),
    
    validPair : Person >< Person -> Bool
    validPair(p) is
    let
        (p1,p2) = p
    in
        p1 ~= <..> /\ p2 ~= <..>
    end,
    
    -- is it possible to check for the nof elems in a group (to make sure that all groups have at least 2 ppl?
    isCorrectGrouping : Grouping >< Person-set >< Relation -> Bool
    isCorrectGrouping(gs,ps,r) is
        (all p : Person :- p isin ps =>
            (exists g : Group :- g isin gs /\
                (all p1 : Person :- p1 isin g =>
                    (all p2 : Person :- p2 isin g =>
                        ~areFriends(p1, p2, r) /\ p isin g
                    )
                )
            ) 
        ),
      
    areFriends : Person >< Person >< Relation -> Bool
    areFriends(p1, p2, r) is ((p1, p2) isin r)
    
  test_case
    [areFriends] areFriends("Anna", "Henrik", r) = true,
    [correctGrouping] isCorrectGrouping(ging, {"Hans","Henrik", "Mette", "Frederik", "Joachim", "Peter", "Anna"}, r) = true,
    [t3] isFriendsRelation(badRelation) = false,
    [t4] isFriendsRelation(r) = true
end
